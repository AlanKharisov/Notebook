<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Кулінарна книга</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <style>
        :root{
            --grass-1: #35da0d;
            --grass-2: #1c6204;

            --primary-color: var(--grass-1);
            --secondary-color: var(--grass-2);
            --primary-light: #57b833;
            --accent-color: #49b028;

            --text-color: #0f172a;
            --light-text: #ffffff;
            --background: #f8fafc;
            --card-bg: #ffffff;
            --border: #e5e7eb;

            --shadow: 0 8px 22px rgba(2, 6, 23, 0.06);
            --radius: 14px;
            --transition: all .25s ease;

            --base-font: 18px;
            --h1: 1.65rem;
            --h3: 1.3rem;
            --text: 1rem;
            --button: 1rem;
            --small: .95rem;
        }

        html{ font-size: var(--base-font); }
        *, *::before, *::after{ box-sizing: border-box; }
        body{
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            margin:0; padding:0;
            background: var(--background);
            color: var(--text-color);
            line-height: 1.65;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .header{
            display:flex; justify-content: space-between; align-items:center;
            background: var(--primary-color);
            padding: .9rem 1.2rem;
            position: sticky; top:0; z-index:100;
            box-shadow: var(--shadow);
            border-bottom: 1px solid rgba(255,255,255,.08);
        }
        .header h1{
            flex:1; text-align:center; margin:0;
            color:var(--light-text); font-size: var(--h1); font-weight:700;
        }
        .header button{
            appearance:none; -webkit-appearance:none;
            background: rgba(255,255,255,.12);
            border: 1px solid rgba(255,255,255,.22);
            color: var(--light-text);
            padding: .6rem 1rem;
            border-radius: 999px;
            font-size: var(--button); font-weight:700;
            cursor:pointer; transition: var(--transition);
            backdrop-filter: saturate(120%) blur(2px);
        }
        .header button:hover{ background: rgba(255,255,255,.2); transform: translateY(-1px); }
        .header button:focus-visible{
            outline: 3px solid rgba(73,176,40,.35);
            outline-offset: 2px;
        }

        .main{ padding: 1.25rem; max-width: 920px; margin: 0 auto; }
        h3{ color: var(--secondary-color); margin: 0 0 1.1rem; font-size: var(--h3); font-weight:800; }

        .category{
            margin-bottom: 1rem; background: var(--card-bg);
            border: 1px solid var(--border); border-radius: var(--radius);
            box-shadow: var(--shadow); transition: var(--transition); overflow:hidden;
        }
        .category:hover{ transform: translateY(-2px); box-shadow: 0 10px 26px rgba(2,6,23,.08); }
        .category-header{
            display:flex; align-items:center; gap:.75rem;
            padding: .85rem 1rem;
            background: var(--secondary-color);
            color: var(--light-text);
        }
        .category button{
            border:none; background:none; color:inherit;
            font-size: var(--text); font-weight:700; text-align:left; flex:1; cursor:pointer;
        }
        .category-actions{ display:flex; gap:.7rem; }
        .category-actions img{
            width:22px; height:22px; cursor:pointer; transition: var(--transition);
            filter: brightness(0) invert(1);
        }
        .category-actions img:hover{ transform: scale(1.08); }

        .dishes{ display:none; padding: 0 1rem 1rem; background: var(--card-bg); }
        .dish{
            display:flex; align-items:center; gap:.75rem;
            padding: .8rem 0; border-bottom:1px solid var(--border);
            transition: var(--transition);
        }
        .dish:last-child{ border-bottom:none; }
        .dish:hover{ background: #f1fbf3; }
        .dish button{
            flex:1; border:none; background:none; text-align:left; cursor:pointer;
            font-size: var(--text); font-weight:600; color: var(--text-color);
            padding:.35rem 0; transition: var(--transition);
        }
        .dish button:hover{ color: var(--primary-color); padding-left: 4px; }
        .dish-actions{ display:flex; gap:.6rem; }
        .dish-actions img{ width:22px; height:22px; cursor:pointer; transition: var(--transition); }
        .dish-actions img:hover{ transform: scale(1.08); }

        .button{
            appearance:none; -webkit-appearance:none;
            background: var(--primary-color);
            color: var(--light-text);
            border: 1px solid rgba(73,176,40,.18);
            padding: .85rem 1.2rem;
            border-radius: var(--radius);
            cursor:pointer; transition: var(--transition);
            font-size: var(--button); font-weight:800; letter-spacing:.2px;
            width:100%; margin:.85rem 0;
            box-shadow: var(--shadow);
        }
        .button:hover{ background: var(--primary-light); transform: translateY(-1px); }
        .button:active{ transform: translateY(0); }
        .button:focus-visible{
            outline: 3px solid rgba(73,176,40,.35);
            outline-offset: 2px;
        }

        .button.secondary{
            background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
            border: 1px solid rgba(73,176,40,.2);
            color: var(--light-text);
            padding: .85rem 1.1rem;
            border-radius: var(--radius);
            font-weight:800;
            box-shadow: 0 8px 20px rgba(73,176,40,.18);
            width:auto;
        }
        .button.secondary:hover{
            background: linear-gradient(135deg, var(--accent-color), var(--primary-light));
            transform: translateY(-1px);
            box-shadow: 0 12px 24px rgba(73,176,40,.24);
        }

        .button.back{
            background: none;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            padding: .5rem 1rem;
            border-radius: 999px;
            font-size: var(--small); font-weight:800;
            width:auto; box-shadow:none;
        }
        .button.back:hover{ background: var(--primary-color); color: var(--light-text); transform: translateY(-1px); }
        .button.back:focus-visible{
            outline: 3px solid rgba(73,176,40,.35);
            outline-offset: 2px;
        }

        .input-group{ margin-bottom: 1.2rem; }
        .input-group input,
        .auth-form input{
            width:100%; padding: .8rem 1rem;
            border:1px solid var(--border); border-radius: var(--radius);
            background:#fff; color: var(--text-color);
            font-size: var(--text); transition: var(--transition);
        }
        .input-group input:focus,
        .auth-form input:focus{
            outline:none; border-color: var(--primary-light);
            box-shadow: 0 0 0 3px rgba(73,176,40,.22);
        }

        .recipe-content{
            margin: 1.2rem 0; padding:0;
            font-size: 1.125rem; line-height:1.8;
            color: var(--text-color);
            white-space: pre-wrap;
            word-wrap: break-word; word-break: break-word; overflow-wrap: break-word;
            max-width:100%; overflow-x:auto;
        }
        .recipe-content.edit-mode{
            background:#f6fdf4;
            border:1px solid var(--primary-light);
            padding: 1.1rem; min-height: 280px;
            border-radius: var(--radius); outline:none; cursor:text;
        }
        .recipe-actions{ display:flex; gap:.8rem; margin-top:.6rem; }
        .recipe-actions button{ width:auto; margin:0; }

        .auth-form{
            position:fixed; inset:0;
            background: rgba(0,0,0,.55);
            display:flex; justify-content:center; align-items:center;
            z-index:1000; backdrop-filter: blur(3px);
        }
        .auth-form .form-container{
            background: var(--card-bg);
            padding: 1.4rem; border-radius: var(--radius);
            box-shadow: 0 16px 36px rgba(2,6,23,.16);
            width:92%; max-width: 440px;
            border: 1px solid var(--border);
            animation: fadeInUp .35s ease-out;
        }
        .auth-form h3{
            text-align:center; margin: 0 0 1rem;
            color: var(--secondary-color); font-weight:800; font-size: var(--h3);
        }
        .auth-form .error-message{
            color:#dc2626; margin-bottom: 1rem; text-align:center; font-size: .95rem;
        }
        .auth-form .switch-form{
            background:none; border:none; color: var(--primary-color);
            cursor:pointer; font-size: var(--small); font-weight:800;
            display:block; margin:.6rem auto 0; text-align:center; width:100%;
            padding:.4rem 0; transition: var(--transition);
        }
        .auth-form .switch-form:hover{ color: var(--primary-light); text-decoration: underline; }

        @media (max-width: 768px){
            .header{ padding: .7rem .9rem; flex-wrap: wrap; }
            .header button{ margin:.25rem; font-size: .95rem; }
            .main{ padding: .95rem; }
            .category-header{ padding:.75rem .9rem; }
        }

        @keyframes fadeIn{
            from{ opacity:0; transform: translateY(8px); }
            to{ opacity:1; transform: translateY(0); }
        }
        @keyframes fadeInUp{
            from{ opacity:0; transform: translateY(16px); }
            to{ opacity:1; transform: translateY(0); }
        }
        .category, .dish, .recipe-content, .button{ animation: fadeIn .35s ease-out; }

        /* ===== Панель таймерів Аска ===== */
        .ask-timers-panel{
            position: fixed;
            right: 1rem;
            bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: .6rem;
            z-index: 200;
        }
        .ask-timer{
            display:flex;
            align-items:center;
            gap:.55rem;
            background: var(--card-bg);
            border-radius: 999px;
            padding: .35rem .8rem .35rem .4rem;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            font-size: .85rem;
        }
        .ask-timer-circle{
            --progress: 0;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: conic-gradient(
                    var(--primary-color) calc(var(--progress) * 360deg),
                    #e5e7eb 0deg
            );
            display:flex;
            align-items:center;
            justify-content:center;
            font-size: .7rem;
            font-weight:700;
            color: var(--text-color);
        }
        .ask-timer-text{
            display:flex;
            flex-direction:column;
            gap:2px;
        }
        .ask-timer-label{
            font-weight:600;
        }
        .ask-timer-eta{
            font-size:.75rem;
            color:#6b7280;
        }

        @media (max-width: 768px){
            .ask-timers-panel{
                right:.6rem;
                bottom:.6rem;
            }
        }
    </style>
</head>
<body>
<div class="header">
    <button id="authButton" onclick="toggleAuthMenu()">Увійти</button>
    <button onclick="showAddMenu()">Додати категорію</button>
</div>

<!-- Кнопка для увімкнення/вимкнення голосу Аска -->
<div class="main" style="padding-top: 0.5rem;">
    <button class="button secondary" id="ask-voice-btn" onclick="toggleAskVoice()">
        Увімкнути голос Аска
    </button>
</div>

<!-- Панель таймерів Аска -->
<div class="ask-timers-panel" id="ask-timers-panel"></div>

<div id="main-menu" class="main">
    <h3>Категорії страв</h3>
    <div id="categories"></div>
</div>

<div id="add-menu" class="main" style="display: none">
    <button class="button back" onclick="goBackFromRecipe()">⬅ Назад</button>
    <h3>Додати категорію</h3>
    <div class="input-group">
        <input
                type="text"
                id="new-category-name"
                placeholder="Назва категорії"
        />
        <button class="button" onclick="addNewCategory()">Додати</button>
    </div>
</div>

<div id="recipe-menu" class="main" style="display: none">
    <button class="button back" onclick="goBackFromRecipe()">⬅ Назад</button>
    <h3 id="recipe-title">Назва страви</h3>
    <div
            class="recipe-content"
            id="recipe-display"
            contenteditable="false"
    ></div>
    <div class="recipe-actions" id="recipe-actions" style="display: none">
        <button class="button" onclick="saveRecipe()">Зберегти</button>
        <button class="button secondary" onclick="cancelEdit()">
            Скасувати
        </button>
    </div>
    <button class="button" id="edit-button" onclick="startEdit()">
        Редагувати
    </button>
</div>

<!-- Auth Forms -->
<div id="auth-menu" class="auth-form" style="display: none">
    <div class="form-container">
        <div id="login-form">
            <h3>Увійти</h3>
            <div id="login-error" class="error-message"></div>
            <input type="email" id="login-email" placeholder="Email" />
            <input type="password" id="login-password" placeholder="Пароль" />
            <button class="button" onclick="login()">Увійти</button>
            <button class="switch-form" onclick="showRegisterForm()">
                Зареєструватися
            </button>
        </div>
        <div id="register-form" style="display: none">
            <h3>Реєстрація</h3>
            <div id="register-error" class="error-message"></div>
            <input type="text" id="register-name" placeholder="Ім'я" />
            <input type="email" id="register-email" placeholder="Email" />
            <input type="password" id="register-password" placeholder="Пароль" />
            <input
                    type="password"
                    id="register-confirm-password"
                    placeholder="Підтвердіть пароль"
            />
            <button class="button" onclick="register()">Зареєструватися</button>
            <button class="switch-form" onclick="showLoginForm()">
                Вже маєте акаунт? Увійти
            </button>
        </div>
    </div>
</div>

<script>
    // ==================== Конфігурація Firebase ====================
    const firebaseConfig = {
        apiKey: "AIzaSyCsi129Y9ltNjMbNPU8D9s1JURMxVyeHYs",
        authDomain: "notebook-66f4e.firebaseapp.com",
        databaseURL: "https://notebook-66f4e-default-rtdb.firebaseio.com",
        projectId: "notebook-66f4e",
        storageBucket: "notebook-66f4e.appspot.com",
        messagingSenderId: "1234567890",
        appId: "1:1234567890:web:abcdef1234567890",
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();

    let currentUser = null;
    let currentCat = null;
    let currentDish = null;

    // ==================== Аутентифікація ====================
    function toggleAuthMenu() {
        if (currentUser) {
            if (confirm("Вийти?")) {
                auth.signOut();
            }
        } else {
            document.getElementById("auth-menu").style.display = "flex";
            showLoginForm();
        }
    }

    function showLoginForm() {
        document.getElementById("login-form").style.display = "block";
        document.getElementById("register-form").style.display = "none";
        document.getElementById("login-error").textContent = "";
    }

    function showRegisterForm() {
        document.getElementById("login-form").style.display = "none";
        document.getElementById("register-form").style.display = "block";
        document.getElementById("register-error").textContent = "";
    }

    auth.onAuthStateChanged((user) => {
        if (user) {
            currentUser = user;
            hideAuthMenu();
            loadCategories();
            document.getElementById("authButton").textContent = "Вийти";
        } else {
            currentUser = null;
            document.getElementById("categories").innerHTML = "";
            document.getElementById("authButton").textContent = "Увійти";
            showMainMenu();
        }
    });

    function hideAuthMenu() {
        document.getElementById("auth-menu").style.display = "none";
    }

    function login() {
        const email = document.getElementById("login-email").value;
        const password = document.getElementById("login-password").value;
        const error = document.getElementById("login-error");

        auth
            .signInWithEmailAndPassword(email, password)
            .catch((err) => (error.textContent = err.message));
    }

    function register() {
        const name = document.getElementById("register-name").value.trim();
        const email = document.getElementById("register-email").value;
        const password = document.getElementById("register-password").value;
        const confirm = document.getElementById("register-confirm-password").value;
        const error = document.getElementById("register-error");

        if (password !== confirm) {
            error.textContent = "Паролі не співпадають";
            return;
        }

        auth
            .createUserWithEmailAndPassword(email, password)
            .then((cred) => {
                return db
                    .ref(`users/${cred.user.uid}/profile`)
                    .set({ name, email });
            })
            .then(() => {
                hideAuthMenu();
            })
            .catch((err) => (error.textContent = err.message));
    }

    // ==================== Категорії ====================
    function loadCategories() {
        if (!currentUser) return;
        db.ref(`users/${currentUser.uid}/categories`)
            .once("value")
            .then((snap) => {
                const data = snap.val() || {};
                renderCategories(data);
            });
    }

    function renderCategories(categories) {
        const container = document.getElementById("categories");
        container.innerHTML = "";

        for (const [catId, cat] of Object.entries(categories)) {
            const div = document.createElement("div");
            div.className = "category";

            div.innerHTML = `
        <div class="category-header">
          <button onclick="toggleDishes('${catId}')">${escapeHtml(cat.name)}</button>
          <div class="category-actions">
            <img src="https://cdn-icons-png.flaticon.com/512/2921/2921222.png" title="Редагувати категорію" onclick="editCategory('${catId}')" />
            <img src="https://cdn-icons-png.flaticon.com/512/484/484662.png" title="Видалити категорію" onclick="deleteCategory('${catId}')" />
          </div>
        </div>
        <div class="dishes" id="dishes-${catId}" style="display:none;"></div>
      `;

            container.appendChild(div);
        }
    }

    function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
    }

    function showAddMenu() {
        document.getElementById("new-category-name").value = "";
        showScreen("add-menu");
    }

    function addNewCategory() {
        const name = document.getElementById("new-category-name").value.trim();
        if (!name) return alert("Введіть назву");

        const catId = db.ref().push().key;
        db.ref(`users/${currentUser.uid}/categories/${catId}`)
            .set({
                name,
                dishes: {},
            })
            .then(() => {
                showMainMenu();
                loadCategories();
            });
    }

    function editCategory(catId) {
        db.ref(`users/${currentUser.uid}/categories/${catId}/name`)
            .once("value")
            .then((snap) => {
                const oldName = snap.val() || "";
                const newName = prompt("Нова назва категорії:", oldName);
                if (newName && newName.trim() !== "" && newName !== oldName) {
                    db.ref(`users/${currentUser.uid}/categories/${catId}/name`)
                        .set(newName.trim())
                        .then(loadCategories);
                }
            });
    }

    function deleteCategory(catId) {
        if (!confirm("Видалити категорію?")) return;
        db.ref(`users/${currentUser.uid}/categories/${catId}`)
            .remove()
            .then(loadCategories);
    }

    // ==================== Страви ====================
    function toggleDishes(catId) {
        const container = document.getElementById(`dishes-${catId}`);
        if (container.style.display === "block") {
            container.style.display = "none";
            container.innerHTML = "";
        } else {
            loadDishes(catId);
            container.style.display = "block";
        }
    }

    function loadDishes(catId) {
        db.ref(`users/${currentUser.uid}/categories/${catId}/dishes`)
            .once("value")
            .then((snap) => {
                const dishes = snap.val() || {};
                renderDishes(catId, dishes);
            });
    }

    function renderDishes(catId, dishes) {
        const container = document.getElementById(`dishes-${catId}`);
        container.innerHTML = `<button class="button secondary" onclick="addDish('${catId}')">+ Додати страву</button>`;

        for (const [dishId, dish] of Object.entries(dishes)) {
            container.insertAdjacentHTML(
                "beforeend",
                `
        <div class="dish">
          <button onclick="openDish('${catId}','${dishId}')">${escapeHtml(dish.name)}</button>
          <div class="dish-actions">
            <img src="https://cdn-icons-png.flaticon.com/512/2921/2921222.png" title="Редагувати страву" onclick="editDish('${catId}','${dishId}')" />
            <img src="https://cdn-icons-png.flaticon.com/512/484/484662.png" title="Видалити страву" onclick="deleteDish('${catId}','${dishId}')" />
          </div>
        </div>
      `
            );
        }
    }

    function addDish(catId) {
        const name = prompt("Назва страви?");
        if (!name || !name.trim()) return;
        const dishId = db.ref().push().key;
        db.ref(`users/${currentUser.uid}/categories/${catId}/dishes/${dishId}`)
            .set({
                name: name.trim(),
                description: "",
            })
            .then(() => loadDishes(catId));
    }

    function editDish(catId, dishId) {
        db.ref(`users/${currentUser.uid}/categories/${catId}/dishes/${dishId}/name`)
            .once("value")
            .then((snap) => {
                const oldName = snap.val() || "";
                const newName = prompt("Введіть нову назву страви:", oldName);
                if (newName && newName.trim() !== "" && newName !== oldName) {
                    db.ref(`users/${currentUser.uid}/categories/${catId}/dishes/${dishId}/name`)
                        .set(newName.trim())
                        .then(() => loadDishes(catId));
                }
            });
    }

    function deleteDish(catId, dishId) {
        if (!confirm("Видалити страву?")) return;
        db.ref(`users/${currentUser.uid}/categories/${catId}/dishes/${dishId}`)
            .remove()
            .then(() => loadDishes(catId));
    }

    // ==================== Рецепт ====================
    function openDish(catId, dishId) {
        currentCat = catId;
        currentDish = dishId;
        db.ref(`users/${currentUser.uid}/categories/${catId}/dishes/${dishId}`)
            .once("value")
            .then((snap) => {
                const dish = snap.val();
                if (!dish) return alert("Страва не знайдена");
                document.getElementById("recipe-title").textContent = dish.name;
                document.getElementById("recipe-display").textContent =
                    dish.description || "";
                showScreen("recipe-menu");
                cancelEdit();
            });
    }

    function startEdit() {
        const disp = document.getElementById("recipe-display");
        disp.contentEditable = "true";
        disp.classList.add("edit-mode");
        disp.focus();
        document.getElementById("edit-button").style.display = "none";
        document.getElementById("recipe-actions").style.display = "flex";
    }

    function saveRecipe() {
        const desc = document.getElementById("recipe-display").innerText.trim();
        db.ref(
            `users/${currentUser.uid}/categories/${currentCat}/dishes/${currentDish}/description`
        )
            .set(desc)
            .then(() => {
                cancelEdit();
            });
    }

    function cancelEdit() {
        document.getElementById("recipe-display").contentEditable = "false";
        document.getElementById("recipe-display").classList.remove("edit-mode");
        document.getElementById("edit-button").style.display = "block";
        document.getElementById("recipe-actions").style.display = "none";
    }

    // ==================== Навігація ====================
    function showScreen(id) {
        ["main-menu", "add-menu", "recipe-menu"].forEach((s) => {
            document.getElementById(s).style.display =
                s === id ? "block" : "none";
        });
    }

    function showMainMenu() {
        showScreen("main-menu");
        if (currentUser) {
            loadCategories();
        }
    }

    function goBackFromRecipe() {
        currentCat = null;
        currentDish = null;
        showMainMenu();
    }

    // ==================== Голосовий асистент Аск + таймери ====================
    let askAwake = false;
    let askInactivityTimer = null;
    let recognition = null;
    let askVoice = null;

    // нові прапорці для голосу
    let askVoiceEnabled = false;
    let askAlwaysAwake = false;

    // Таймери
    let askTimers = []; // {id,label,endTime,durationMs}
    let timersIntervalId = null;
    let audioCtx = null;

    // Читання рецепта з позицією
    let askCurrentUtterance = null;
    let askManuallyStopped = false;
    let askCurrentDishKey = null;

    function makeDishKey(catId, dishId) {
        if (!currentUser || !catId || !dishId) return null;
        return `${currentUser.uid}:${catId}:${dishId}`;
    }

    function storageKeyForDish(dishKey) {
        return `ask_read_pos_${dishKey}`;
    }

    function saveReadingPosition(dishKey, pos) {
        if (!dishKey) return;
        try {
            localStorage.setItem(storageKeyForDish(dishKey), String(pos));
        } catch (e) {
            console.warn("Не вдалося зберегти позицію читання:", e);
        }
    }

    function getReadingPosition(dishKey) {
        if (!dishKey) return 0;
        try {
            const v = localStorage.getItem(storageKeyForDish(dishKey));
            if (!v) return 0;
            const n = parseInt(v, 10);
            return isNaN(n) ? 0 : n;
        } catch (e) {
            return 0;
        }
    }

    function clearReadingPosition(dishKey) {
        if (!dishKey) return;
        try {
            localStorage.removeItem(storageKeyForDish(dishKey));
        } catch (e) {}
    }

    // ===== Парсинг рецепта: інгредієнти + Опис =====
    function extractRecipeParts(fullText) {
        const lines = fullText.split(/\r?\n/);
        const ingredients = {};
        const descriptionLines = [];
        let inDescription = false;

        for (let raw of lines) {
            const line = raw.trim();
            if (!line) continue;

            const lower = line.toLowerCase();

            if (lower.startsWith("опис")) {
                inDescription = true;
                continue;
            }

            if (inDescription) {
                descriptionLines.push(line);
            } else {
                const dashIdx = line.indexOf("-");
                if (dashIdx > 0) {
                    const name = line.slice(0, dashIdx).trim().toLowerCase();
                    const amount = line.slice(dashIdx + 1).trim();
                    if (name && amount) {
                        ingredients[name] = amount;
                    }
                }
            }
        }

        const description = descriptionLines.join(" ");
        return { ingredients, description };
    }

    function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function buildDescriptionWithAmounts(fullText) {
        const { ingredients, description } = extractRecipeParts(fullText);
        let text = description || fullText || "";

        for (const [name, amount] of Object.entries(ingredients)) {
            if (!name || !amount) continue;
            const escaped = escapeRegExp(name);
            const regex = new RegExp(escaped, "gi");
            text = text.replace(regex, (match) => `${match} (${amount})`);
        }

        return text;
    }

    // ===== Таймери: збереження, UI, звук =====
    function loadTimersFromStorage() {
        try {
            const raw = localStorage.getItem("ask_timers");
            if (!raw) return [];
            const arr = JSON.parse(raw);
            if (!Array.isArray(arr)) return [];
            return arr.map(t => ({
                id: t.id,
                label: t.label || "таймер",
                endTime: Number(t.endTime),
                durationMs: Number(t.durationMs) || 0
            })).filter(t => t.endTime && t.durationMs);
        } catch (e) {
            console.warn("Не вдалося прочитати таймери:", e);
            return [];
        }
    }

    function saveTimersToStorage() {
        try {
            localStorage.setItem("ask_timers", JSON.stringify(askTimers));
        } catch (e) {
            console.warn("Не вдалося зберегти таймери:", e);
        }
    }

    function playTimerBeep() {
        try {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return;
            if (!audioCtx) audioCtx = new Ctx();

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.frequency.value = 900;
            osc.type = "sine";
            gain.gain.setValueAtTime(0.25, audioCtx.currentTime);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.4);
        } catch (e) {
            console.warn("Не вдалося програти звук таймера:", e);
        }
    }

    function onTimerEnd(timerId) {
        const idx = askTimers.findIndex(t => t.id === timerId);
        if (idx === -1) return;
        const timer = askTimers[idx];

        playTimerBeep();
        sayWithAsk(`Час вийшов. ${timer.label} готовий.`);

        askTimers.splice(idx, 1);
        saveTimersToStorage();
        renderTimersUI();
    }

    function scheduleTimerTimeout(timer) {
        const now = Date.now();
        const diff = timer.endTime - now;
        if (diff <= 0) {
            onTimerEnd(timer.id);
            return;
        }
        setTimeout(() => {
            onTimerEnd(timer.id);
        }, diff);
    }

    function formatTimeLeft(ms) {
        if (ms < 0) ms = 0;
        const totalSec = Math.floor(ms / 1000);
        const m = Math.floor(totalSec / 60);
        const s = totalSec % 60;
        const mm = m.toString();
        const ss = s.toString().padStart(2, "0");
        return `${mm}:${ss}`;
    }

    function renderTimersUI() {
        const panel = document.getElementById("ask-timers-panel");
        if (!panel) return;

        const now = Date.now();
        if (!askTimers.length) {
            panel.innerHTML = "";
            return;
        }

        let html = "";
        askTimers.forEach(t => {
            const remaining = t.endTime - now;
            const clamped = Math.max(0, remaining);
            const progress = t.durationMs > 0 ? clamped / t.durationMs : 0;
            const timeStr = formatTimeLeft(remaining);
            const eta = remaining <= 0 ? "зараз" : "ще трохи";

            html += `
              <div class="ask-timer">
                <div class="ask-timer-circle" style="--progress:${progress}">
                  ${timeStr}
                </div>
                <div class="ask-timer-text">
                  <div class="ask-timer-label">${escapeHtml(t.label)}</div>
                  <div class="ask-timer-eta">${eta}</div>
                </div>
              </div>
            `;
        });

        panel.innerHTML = html;
    }

    function startTimersUIUpdater() {
        if (timersIntervalId) return;
        timersIntervalId = setInterval(() => {
            renderTimersUI();
        }, 500);
    }

    function initTimers() {
        askTimers = loadTimersFromStorage();

        const now = Date.now();
        const stillActive = [];
        askTimers.forEach(t => {
            if (t.endTime <= now) {
                playTimerBeep();
                sayWithAsk(`Час вийшов. ${t.label} готовий.`);
            } else {
                stillActive.push(t);
                scheduleTimerTimeout(t);
            }
        });
        askTimers = stillActive;
        saveTimersToStorage();
        renderTimersUI();
        startTimersUIUpdater();
    }

    function createAskTimer(durationMs, label) {
        const id = Date.now() + "_" + Math.random().toString(16).slice(2);
        const endTime = Date.now() + durationMs;
        const timer = { id, label, endTime, durationMs };

        askTimers.push(timer);
        saveTimersToStorage();
        scheduleTimerTimeout(timer);
        renderTimersUI();
    }

    function stopNearestTimer() {
        if (!askTimers.length) {
            sayWithAsk("Зараз жодного таймера немає.");
            return;
        }
        askTimers.sort((a, b) => a.endTime - b.endTime);
        const t = askTimers.shift();
        saveTimersToStorage();
        renderTimersUI();
        sayWithAsk(`Зупиняю таймер ${t.label}.`);
    }

    function stopAllTimers() {
        if (!askTimers.length) {
            sayWithAsk("Зараз жодного таймера немає.");
            return;
        }
        askTimers = [];
        saveTimersToStorage();
        renderTimersUI();
        sayWithAsk("Зупиняю всі таймери.");
    }

    // ===== Голос: базові речі =====
    function initAsk() {
        const hasRecognition = ("webkitSpeechRecognition" in window || "SpeechRecognition" in window);
        if (!hasRecognition) {
            console.warn("SpeechRecognition не підтримується цим браузером.");
            return;
        }

        if ("speechSynthesis" in window) {
            const pickVoice = () => {
                const voices = window.speechSynthesis.getVoices();
                askVoice =
                    voices.find(v => v.lang && v.lang.toLowerCase().startsWith("uk") && v.name.toLowerCase().includes("female")) ||
                    voices.find(v => v.lang && v.lang.toLowerCase().startsWith("uk")) ||
                    null;
            };
            pickVoice();
            window.speechSynthesis.onvoiceschanged = pickVoice;
        }

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.lang = "uk-UA";
        recognition.continuous = true;
        recognition.interimResults = false;

        recognition.onresult = function (event) {
            const lastResult = event.results[event.results.length - 1];
            const text = lastResult[0].transcript.trim().toLowerCase();
            console.log("Ask heard:", text);
            handleAskTranscript(text);
        };

        recognition.onend = function () {
            try { recognition.start(); } catch (e) {}
        };

        recognition.onerror = function (event) {
            console.error("Ask error:", event.error);
        };

        try { recognition.start(); } catch (e) {}
    }

    function resetAskInactivityTimer() {
        if (!askAwake) return;

        // Якщо голос увімкнено в режимі "завжди прокинутого" — не засинаємо
        if (askAlwaysAwake) {
            return;
        }

        clearTimeout(askInactivityTimer);
        askInactivityTimer = setTimeout(() => {
            askAwake = false;
        }, 30000);
    }

    function sayWithAsk(text) {
        if (!("speechSynthesis" in window)) return;
        if (!askVoiceEnabled) {
            console.log("ASK (mute):", text);
            return;
        }

        console.log("ASK SAY:", text);

        try { window.speechSynthesis.cancel(); } catch (e) {}

        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = "uk-UA";

        utter.rate = 0.9;   // повільніше
        utter.pitch = 1.05; // трохи м'якше
        utter.volume = 1.0;

        if (askVoice) utter.voice = askVoice;

        window.speechSynthesis.speak(utter);
    }

    function stopReading() {
        if (!("speechSynthesis" in window)) return;
        if (window.speechSynthesis.speaking || window.speechSynthesis.pending) {
            askManuallyStopped = true;
            window.speechSynthesis.cancel();
        }
    }

    function speakRecipeFromPosition(fullText, dishKey, startPos) {
        if (!("speechSynthesis" in window)) return;
        if (!fullText) return;

        const text = fullText;
        const pos = Math.max(0, Math.min(startPos || 0, text.length));

        try { window.speechSynthesis.cancel(); } catch (e) {}
        askCurrentDishKey = dishKey;
        askManuallyStopped = false;

        const utter = new SpeechSynthesisUtterance(text.slice(pos));
        utter.lang = "uk-UA";
        utter.rate = 0.9;
        utter.pitch = 1.05;
        utter.volume = 1.0;
        if (askVoice) utter.voice = askVoice;

        let lastChar = pos;

        utter.onboundary = function (e) {
            if (typeof e.charIndex === "number") {
                lastChar = pos + e.charIndex;
                saveReadingPosition(dishKey, lastChar);
            }
        };

        utter.onend = function () {
            askCurrentUtterance = null;
            if (!askManuallyStopped) {
                clearReadingPosition(dishKey);
            }
            askManuallyStopped = false;
        };

        askCurrentUtterance = utter;
        window.speechSynthesis.speak(utter);
    }

    // Кнопка вкл/викл голосу Аска
    function toggleAskVoice() {
        const btn = document.getElementById("ask-voice-btn");
        askVoiceEnabled = !askVoiceEnabled;
        askAlwaysAwake = askVoiceEnabled;

        if (askVoiceEnabled) {
            btn.textContent = "Вимкнути голос Аска";
            askAwake = true;
            sayWithAsk("Голос Аска увімкнено. Я слухаю.");
        } else {
            btn.textContent = "Увімкнути голос Аска";
            askAwake = false;
            try { window.speechSynthesis.cancel(); } catch (e) {}
        }
    }

    function handleAskTranscript(text) {
        // Привітання — завжди будить і (якщо голос увімкнений) каже "Слухаю."
        if (
            text.includes("привіт аск") ||
            text.includes("привіт аско") ||
            text.includes("привет аск") ||
            text.includes("привіт") ||
            text.includes("привет")
        ) {
            askAwake = true;
            sayWithAsk("Слухаю.");
            resetAskInactivityTimer();
            return;
        }

        // Якщо не прокинувся — ігноруємо все інше
        if (!askAwake) return;

        // Стоп читання рецепта
        if (
            text.includes("стоп читання") ||
            text.includes("стоп рецепт") ||
            (text.includes("стоп") && text.includes("опис"))
        ) {
            stopReading();
            resetAskInactivityTimer();
            return;
        }

        // Проста команда "стоп" — теж зупиняє читання
        if (text === "стоп" || text.includes("зупинись") || text.includes("зупинися")) {
            stopReading();
            resetAskInactivityTimer();
            return;
        }

        // Зупинити таймер(и)
        if (
            text.includes("зупини таймер") ||
            text.includes("останови таймер") ||
            text.includes("зупини таймера") ||
            text.includes("останови таймера")
        ) {
            stopNearestTimer();
            resetAskInactivityTimer();
            return;
        }

        if (
            text.includes("зупини всі таймери") ||
            text.includes("зупини все таймери") ||
            text.includes("останови всі таймери") ||
            text.includes("останови все таймеры")
        ) {
            stopAllTimers();
            resetAskInactivityTimer();
            return;
        }

        // Закрити рецепт / назад
        if (text.includes("закрий") || text.includes("назад")) {
            const recipeVisible = document.getElementById("recipe-menu").style.display === "block";
            if (recipeVisible) {
                goBackFromRecipe();
                sayWithAsk("Закриваю рецепт.");
                resetAskInactivityTimer();
                return;
            }
        }

        // Таймер (створити)
        if (text.includes("таймер")) {
            const ok = setAskTimerFromText(text);
            if (ok) {
                resetAskInactivityTimer();
                return;
            }
        }

        // Скільки часу
        if (text.includes("скільки часу") || text.includes("сколько времени")) {
            tellAskTimeLeft();
            resetAskInactivityTimer();
            return;
        }

        // Рецепт (поточний)
        if (text.includes("рецепт") && (text.includes("зачитай") || text.includes("прочитай"))) {
            const fromStart = text.includes("заново") || text.includes("спочатку");
            readCurrentRecipe(fromStart);
            resetAskInactivityTimer();
            return;
        }

        // Опис Х
        if (text.includes("опис") && (text.includes("прочитай") || text.includes("зачитай"))) {
            const fromStart = text.includes("заново") || text.includes("спочатку");
            readRecipeDescriptionByVoice(text, fromStart);
            resetAskInactivityTimer();
            return;
        }

        // Відкрий страву
        if (text.includes("відкрий") || text.includes("открой")) {
            openDishByVoice(text);
            resetAskInactivityTimer();
            return;
        }
    }

    function setAskTimerFromText(text) {
        const match = text.match(/(\d+)\s*(секунд|секунди|секунду|секунды|хвилин|хвилини|хвилину|минут|минуту)/);
        if (!match) {
            sayWithAsk("Я не почула тривалість таймера.");
            return false;
        }

        const value = parseInt(match[1], 10);
        const unit = match[2];
        let ms = 0;

        if (unit.startsWith("сек")) {
            ms = value * 1000;
        } else {
            ms = value * 60 * 1000;
        }

        let label = "таймер";
        const idx = text.indexOf("для ");
        if (idx !== -1) {
            label = text.substring(idx + 4).trim();
            if (!label) label = "таймер";
        }

        createAskTimer(ms, label);
        sayWithAsk(`Ставлю таймер на ${value} ${unit}.`);
        return true;
    }

    function tellAskTimeLeft() {
        if (!askTimers.length) {
            sayWithAsk("Жодного таймера зараз немає.");
            return;
        }
        const now = Date.now();
        askTimers.sort((a, b) => a.endTime - b.endTime);
        const nearest = askTimers[0];
        let diff = Math.max(0, nearest.endTime - now);

        const minutes = Math.floor(diff / (60 * 1000));
        const seconds = Math.floor((diff % (60 * 1000)) / 1000);

        let phrase = "";
        if (minutes > 0) {
            phrase += `${minutes} хвилин `;
        }
        phrase += `${seconds} секунд`;

        sayWithAsk(`До завершення найближчого таймера залишилось ${phrase}.`);
    }

    function readCurrentRecipe(fromStart) {
        const el = document.getElementById("recipe-display");
        if (!el || !currentCat || !currentDish) {
            sayWithAsk("Немає відкритого рецепта.");
            return;
        }
        const fullText = el.textContent.trim();
        if (!fullText) {
            sayWithAsk("Цей рецепт поки порожній.");
            return;
        }

        const textForReading = buildDescriptionWithAmounts(fullText);
        const dishKey = makeDishKey(currentCat, currentDish);
        const pos = fromStart ? 0 : getReadingPosition(dishKey);
        if (fromStart) clearReadingPosition(dishKey);

        speakRecipeFromPosition(textForReading, dishKey, pos);
    }

    function openDishByVoice(text) {
        if (!currentUser) {
            sayWithAsk("Спочатку увійдіть у свій акаунт.");
            return;
        }

        let namePart = "";
        const idxUk = text.indexOf("відкрий");
        const idxRu = text.indexOf("открой");
        let idx = -1;

        if (idxUk !== -1) idx = idxUk;
        else if (idxRu !== -1) idx = idxRu;

        if (idx !== -1) {
            namePart = text.substring(idx + (idxUk !== -1 ? "відкрий".length : "открой".length)).trim();
        } else {
            namePart = text.trim();
        }

        if (!namePart) {
            sayWithAsk("Я не почула назву страви.");
            return;
        }

        const norm = namePart.toLowerCase();

        db.ref(`users/${currentUser.uid}/categories`)
            .once("value")
            .then((snap) => {
                const cats = snap.val() || {};
                let found = false;
                for (const [catId, cat] of Object.entries(cats)) {
                    const dishes = cat.dishes || {};
                    for (const [dishId, dish] of Object.entries(dishes)) {
                        if (!dish.name) continue;
                        const dn = dish.name.toLowerCase();
                        if (dn.includes(norm) || norm.includes(dn)) {
                            openDish(catId, dishId);
                            sayWithAsk(`Відкриваю страву ${dish.name}.`);
                            found = true;
                            break;
                        }
                    }
                    if (found) break;
                }
                if (!found) {
                    sayWithAsk("Я не знайшла таку страву у вашій кулінарній книзі.");
                }
            });
    }

    function readRecipeDescriptionByVoice(text, fromStart) {
        if (!currentUser) {
            sayWithAsk("Спочатку увійдіть у свій акаунт.");
            return;
        }

        let namePart = "";
        const idxOpis = text.indexOf("опис");
        if (idxOpis !== -1) {
            namePart = text.substring(idxOpis + "опис".length).trim();
        } else {
            namePart = text.trim();
        }

        if (!namePart) {
            readCurrentRecipe(fromStart);
            return;
        }

        const norm = namePart.toLowerCase();

        db.ref(`users/${currentUser.uid}/categories`)
            .once("value")
            .then((snap) => {
                const cats = snap.val() || {};
                let dishName = null;
                let fullText = null;
                let foundCatId = null;
                let foundDishId = null;

                for (const [catId, cat] of Object.entries(cats)) {
                    const dishes = cat.dishes || {};
                    for (const [dishId, dish] of Object.entries(dishes)) {
                        if (!dish.name) continue;
                        const dn = dish.name.toLowerCase();
                        if (dn.includes(norm) || norm.includes(dn)) {
                            dishName = dish.name;
                            fullText = dish.description || "";
                            foundCatId = catId;
                            foundDishId = dishId;
                            break;
                        }
                    }
                    if (dishName !== null) break;
                }

                if (dishName === null) {
                    sayWithAsk("Я не знайшла таку страву у вашій кулінарній книзі.");
                    return;
                }

                if (!fullText.trim()) {
                    sayWithAsk(`Для страви ${dishName} поки немає опису.`);
                    return;
                }

                openDish(foundCatId, foundDishId);

                const textForReading = buildDescriptionWithAmounts(fullText);
                const dishKey = makeDishKey(foundCatId, foundDishId);
                const pos = fromStart ? 0 : getReadingPosition(dishKey);
                if (fromStart) clearReadingPosition(dishKey);

                speakRecipeFromPosition(textForReading, dishKey, pos);
            });
    }

    // ==================== Ініціалізація ====================
    document.addEventListener("DOMContentLoaded", () => {
        showMainMenu();
        initAsk();
        initTimers();
    });
</script>
</body>
</html>
